{
    "task": "cubical", 
    "base": "stimela/cubical", 
    "tag": "1.4.2", 
    "description": "CubiCal is a suite of fast radio interferometric calibration routines exploiting complex optimisation.", 
    "prefix": "--",
    "version":"1.5.1",
    "binary": "gocubical",
    "junk":["cubical.last", "montblanc.log"],
    "msdir": true, 
    "parameters": [
        {
            "info": "Name of measurement set (MS)", 
            "dtype": "file", 
            "default": null, 
            "name": "data-ms", 
            "io": "msfile"
        }, 
        {
            "info": "Name of MS column to read for data.", 
            "dtype": "str", 
            "default": null, 
            "name": "data-column"
        }, 
        {
            "info": "Chunk data up by this number of timeslots. This limits the amount of data\nprocessed at once. Smaller chunks allow for a smaller RAM footprint and\ngreater parallelism, but this sets an upper limit on the solution intervals\nthat may be employed. 0 means use full time axis.", 
            "dtype": "int", 
            "default": null, 
            "name": "data-time-chunk"
        }, 
        {
            "info": "Chunk data by this number of channels. See time-chunk for info.\n0 means full frequency axis.", 
            "dtype": "int", 
            "default": null, 
            "name": "data-freq-chunk"
        }, 
        {
            "info": "If set, then time chunks will be broken up whenever the value in the named\ncolumn(s) jumps by >JUMPSIZE. Multiple column names may be given, separated\nby commas. Use None to disable.", 
            "dtype": "str", 
            "default": null, 
            "name": "data-chunk-by"
        }, 
        {
            "info": "The jump size used in conjunction with chunk-by. If 0, then any change in\nvalue is a jump. If n, then the change must be >n.", 
            "dtype": "float", 
            "default": null, 
            "name": "data-chunk-by-jump"
        }, 
        {
            "info": "If set, processes just one chunk of data matching the chunk ID. Useful for\ndebugging.", 
            "dtype": "str", 
            "default": null, 
            "name": "data-single-chunk"
        }, 
        {
            "info": "FIELD_ID to read from the MS.", 
            "dtype": "int", 
            "default": null, 
            "name": "sel-field"
        }, 
        {
            "info": "DATA_DESC_IDs to read from the MS. Default reads all. Can be specified as\ne.g. \"5\", \"5,6,7\", \"5~7\" (inclusive range), \"5:8\" (exclusive range),\n\"5:\" (from 5 to last).", 
            "dtype": "str", 
            "default": null, 
            "name": "sel-ddid"
        }, 
        {
            "info": "Additional TaQL selection string. Combined with other selection options.", 
            "dtype": "str", 
            "default": null, 
            "name": "sel-taql"
        }, 
        {
            "info": "Channels to read (within each DDID). Default reads all. Can be specified as\ne.g. \"5\", \"10~20\" (10 to 20 inclusive), \"10:21\" (same), \"10:\" (from 10 to\nend), \":10\" (0 to 9 inclusive), \"~9\" (same).", 
            "dtype": "str", 
            "default": null, 
            "name": "sel-chan"
        }, 
        {
            "info": "Predict model visibilities from given LSM (using Montblanc). Expects pattern of the style source(+-?source)*(:source(+-?source)*)* where source at present can be a column name, lsm or DDFacet DicoModel. Colons split directions as specifiable as 0-indexed indicies through the gain directions and fix directions switches. If an lsm file is spcified a tagged selection of sources can be picked by appending a @[user tag] option. If a DicoModel is used regions can be extracted from the model components through a @[DS9 polygon regions file].", 
            "default": null, 
            "check_io": false, 
            "name": "model-list", 
            "dtype": "file",
            "io": "output"
        }, 
        {
            "info": "Enable direction-dependent models. If 'auto', this is determined\nby --sol-jones and --model-list, otherwise, enable/disable\nexplicitly.", 
            "dtype": [
                "str", 
                "bool"
            ], 
            "default": "auto", 
            "name": "model-ddes"
        }, 
        {
            "info": "Apply beams if specified eg. 'beam_$(corr)_$(reim).fits' or\n'beam_$(CORR)_$(REIM).fits'", 
            "check_io": false, 
            "name": "model-beam-pattern", 
            "io": "input", 
            "default": null, 
            "dtype": "file"
        }, 
        {
            "info": "Beam l axis", 
            "dtype": "str", 
            "default": null, 
            "name": "model-beam-l-axis"
        }, 
        {
            "info": "Beam m axis", 
            "dtype": "str", 
            "default": null, 
            "name": "model-beam-m-axis"
        }, 
        {
            "info": "Use CPU or GPU for simulation.", 
            "dtype": "str", 
            "default": null, 
            "name": "montblanc-device-type"
        }, 
        {
            "info": "Precision for simulation.", 
            "dtype": "str", 
            "default": null, 
            "name": "montblanc-dtype"
        }, 
        {
            "info": "Simulate using linear or circular feeds.", 
            "dtype": "str", 
            "default": null, 
            "name": "montblanc-feed-type"
        }, 
        {
            "info": "Memory budget in MB for simulation.", 
            "dtype": "int", 
            "default": null, 
            "name": "montblanc-mem-budget"
        }, 
        {
            "info": "verbosity level of Montblanc's console output", 
            "dtype": "str", 
            "default": null, 
            "name": "montblanc-verbosity"
        }, 
        {
            "info": "Column to read weights from. Weights are applied by default. Specify an\nempty string to disable.", 
            "dtype": "str", 
            "default": null, 
            "name": "weight-column"
        }, 
        {
            "info": "Which flagsets will be applied prior to calibration. \nUse \"-FLAGSET\" to apply everything except the named flagset (\"-cubical\" is\nuseful, to ignore the flags of a previous CubiCal run).", 
            "dtype": "str", 
            "default": null, 
            "name": "flags-apply"
        }, 
        {
            "info": "Insert BITFLAG column if it is missing, and initialize a named flagset\nfrom FLAG/FLAG_ROW.", 
            "dtype": "str", 
            "default": null, 
            "name": "flags-auto-init"
        }, 
        {
            "info": "Save flags to named flagset in BITFLAG. If none or 0, will not save.", 
            "dtype": "str", 
            "default": null, 
            "name": "flags-save"
        }, 
        {
            "info": "If true, reninitializes BITFLAG column from scratch. Useful if you ended up\nwith a dead one.", 
            "dtype": "bool", 
            "default": null, 
            "name": "flags-reinit-bitflags"
        }, 
        {
            "info": "If True, will do an extra round of flagging at the end  (post-solution)\nbased on solutions statistics, as per the following options.", 
            "dtype": "bool", 
            "default": null, 
            "name": "flags-post-sol"
        }, 
        {
            "info": "Intervals with chi-squared values larger than this value times the median\nwill be flagged.", 
            "dtype": "str", 
            "default": null, 
            "name": "flags-tf-chisq-median"
        }, 
        {
            "info": "Minimum percentage of unflagged visibilities per time/frequncy slot\nrequired to prevent flagging.", 
            "dtype": "str", 
            "default": null, 
            "name": "flags-tf-np-median"
        }, 
        {
            "info": "Minimum percentage of unflagged visibilities along the time axis required\nto prevent flagging.", 
            "dtype": "str", 
            "default": null, 
            "name": "flags-time-density"
        }, 
        {
            "info": "Minimum percentage of unflagged visibilities along the frequency axis\nrequired to prevent flagging.", 
            "dtype": "str", 
            "default": null, 
            "name": "flags-chan-density"
        }, 
        {
            "info": "Minimum percentage of unflagged visibilities along the DDID axis\nrequired to prevent flagging.", 
            "dtype": "str", 
            "default": null, 
            "name": "flags-ddid-density"
        }, 
        {
            "info": "Enable Mad Max flagging in the solver. This computes the median absolute residual (i.e. median absolute deviation from zero), and flags visibilities exceeding the thresholds", 
            "dtype": "bool", 
            "name": "madmax-enable"
        }, 
        {
            "info": "MAD estimation mode. Use 'corr' for a separate estimate per each baseline and correlation. Otherwise, a single estimate per baseline is computed using 'all' correlations, or only the 'diag' or 'offdiag' correlations.", 
            "dtype": "str", 
            "name": "madmax-estimate", 
            "choices": [
                "corr", 
                "all", 
                "diag", 
                "offdiag"
            ]
        }, 
        {
            "info": "Enable plots for Mad Max flagging. Use 'show' to show figures interactively. Plots will show the worst flagged baseline, and a median flagged baseline, provided the fraction of flagged visibilities is above --flags-mad-plot-thr.", 
            "dtype": "bool", 
            "name": "madmax-plot"
        }, 
        {
            "info": "Threshold (in terms of fraction of visibilities flagged) above which plots will be generated.", 
            "dtype": "float", 
            "name": "madmax-plot-frac-above"
        }, 
        {
            "info": "Flag on on-diagonal (parallel-hand) residuals", 
            "dtype": "bool", 
            "name": "madmax-diag"
        }, 
        {
            "info": "Flag on off-diagonal (cross-hand) residuals", 
            "dtype": "bool", 
            "name": "madmax-offdiag"
        }, 
        {
            "info": "Threshold for global median MAD (MMAD) flagging. MMAD is computed as the median of the per-baseline MADs. Residuals exceeding S*MMAD/1.428 will be flagged. Can be specified", 
            "dtype": "list:float", 
            "name": "madmax-global-threshold"
        }, 
        {
            "info": "Threshold for MAD flagging per baseline (specified in sigmas). Residuals exceeding mad-thr*MAD/1.428 will be flagged. MAD is computed per baseline. This can be specified as a list e.g. N1,N2,N3,... The first value is used to flag residuals before a solution starts (use 0 to disable), the next value is used when the residuals are first recomputed during the solution several iteratins later (see -chi-int), etc. A final pass may be done at the end of the solution. The last value in the list is reused if necessary. Using a list with gradually decreasing values may be sensible. #metavar:SIGMAS", 
            "dtype": "list:float", 
            "name": "madmax-threshold"
        }, 
        {
            "info": "Comma-separated list of Jones terms to enable, e.g. \"G,B,dE\"\n(default: G)", 
            "dtype": "str", 
            "default": null, 
            "name": "sol-jones"
        }, 
        {
            "info": "If true, then data, model and gains are taken to be diagonal. Off-diagonal terms in data and model are ignored. This option is then enforced on all Jones terms.", 
            "dtype": "bool", 
            "name": "sel-diag"
        }, 
        {
            "info": "if true, then data, model and gains are taken to be diagonal. off-diagonal terms in data and model are ignored. this option is then enforced on all jones terms.", 
            "dtype": "bool", 
            "name": "g-diag-only"
        }, 
        {
            "info": "If true, then data, model and gains are taken to be diagonal. Off-diagonal terms in data and model are ignored. This option is then enforced on all Jones terms.", 
            "dtype": "bool", 
            "name": "dd-diag-only"
        }, 
        {
            "info": "Solve in single or double precision", 
            "dtype": "str", 
            "default": null, 
            "name": "sol-precision"
        }, 
        {
            "info": "Theshold for gain accuracy - gains which improve by less than this value\nare considered converged.", 
            "dtype": "str", 
            "default": null, 
            "name": "sol-delta-g"
        }, 
        {
            "info": "Theshold for solution stagnancy - if the chi-squared is improving by less\nthan this value, the gain is considered stalled.", 
            "dtype": "str", 
            "default": null, 
            "name": "sol-delta-chi"
        }, 
        {
            "info": "Number of iterations to perform between chi-suqared checks. This is done to\navoid computing the expensive chi-squared test evey iteration.", 
            "dtype": "str", 
            "default": null, 
            "name": "sol-chi-int"
        }, 
        {
            "info": "Re-estimate chi-squred and noise at the end of a solution cycle. Disabling\nlast rites can save a bit of time, but makes the post-solution stats less\ninformative.", 
            "dtype": "bool", 
            "default": null, 
            "name": "sol-last-rites"
        }, 
        {
            "info": "Minimum percentage of solutions which must have stalled before terminating\nthe solver.", 
            "dtype": "float", 
            "default": null, 
            "name": "sol-stall-quorum"
        }, 
        {
            "info": "Number of iterations per Jones term. If empty, then each Jones\nterm is solved for once, up to convergence, or up to its -max-iter\nsetting.\nOtherwise, set to a list giving the number of iterations per Jones term.\nFor example, given two Jones terms and --sol-num-iter 10,20,10, it will\ndo 10 iterations on the first term, 20 on the second, and 10 again on the\nfirst.", 
            "dtype": [
                "list:int", 
                "list:str"
            ], 
            "default": [50], 
            "name": "sol-term-iters"
        }, 
        {
            "info": "Min baseline length to solve for", 
            "dtype": "float", 
            "default": null, 
            "name": "sol-min-bl"
        }, 
        {
            "info": "Max baseline length to solve for. If 0, no maximum is applied.", 
            "dtype": "float", 
            "default": null, 
            "name": "sol-max-bl"
        }, 
        {
            "info": "Additional subset of data to actually solve for. Any TaQL string may be\nused.", 
            "dtype": "str", 
            "default": null, 
            "name": "sol-subset"
        }, 
        {
            "info": "Load and apply BBCs computed in a previous run. Apply with care! This will\ntend to suppress all unmodelled flux towards the centre of the field.", 
            "dtype": "file", 
            "default": null, 
            "name": "bbc-load-from", 
            "io": "input"
        }, 
        {
            "info": "Compute full 2x2 BBCs (as opposed to diagonal-only). Only useful if you\nreally trust the polarisation information in your sky model.", 
            "dtype": "bool", 
            "default": null, 
            "name": "bbc-compute-2x2"
        }, 
        {
            "info": "Apply full 2x2 BBCs (as opposed to diagonal-only). Only enable this if you\nreally trust the polarisation information in your sky model.", 
            "dtype": "bool", 
            "default": null, 
            "name": "bbc-apply-2x2"
        }, 
        {
            "info": "Compute suggested BBCs at end of run,\nand save them to the given database. It can be useful to have this always\nenabled, since the BBCs provide useful diagnostics of the solution quality\n(and are not actually applied without a load-from setting).", 
            "dtype": "file", 
            "default": "{out[name]}-BBC-field_{sel[field]}-ddid_{sel[ddid]}.parmdb", 
            "name": "bbc-save-to", 
            "io": "output"
        }, 
        {
            "info": "Compute BBCs per-channel (else across entire band).", 
            "dtype": "bool", 
            "default": null, 
            "name": "bbc-per-chan"
        }, 
        {
            "info": "Generate output BBC plots.", 
            "dtype": "bool", 
            "default": null, 
            "name": "bbc-plot"
        }, 
        {
            "info": "Number of CPUs (processes) to use (0 or 1 disables parallelism).", 
            "dtype": "int", 
            "default": null, 
            "name": "dist-ncpu"
        }, 
        {
            "info": "Maximum number of time/freq data-chunks to load into memory simultaneously. If 0, then as many as possible will be loaded.", 
            "dtype": "int", 
            "default": 0, 
            "name": "dist-max-chunks"
        }, 
        {
            "info": "Number of OMP threads to use. 0: determine automatically.", 
            "dtype": "int", 
            "name": "dist-nthread"
        }, 
        {
            "info": "If empty or None, processes will not be pinned to cores. Otherwise, set to the starting core number, or 'N:K' to start with N and step by K", 
            "dtype": "int", 
            "name": "dist-pin"
        }, 
        {
            "info": "If not 0, pins the I/O & Montblanc process to a separate core, or cores if --montblanc-threads is specified). Ignored if --dist-pin is not set", 
            "dtype": "bool", 
            "name": "dist-pin-io"
        }, 
        {
            "info": "If set, pins the main process to a separate core. If set to, pins it to the same core as the I/O process, if I/O process is pinned. Ignored if --dist-pin is not set", 
            "dtype": [
                "bool", 
                "str"
            ], 
            "name": "pin-main"
        }, 
        {
            "info": "Minimum number of time/freq data-chunks to load into memory\nsimultaneously. This number should be divisible by ncpu-1 for optimal\nperformance.", 
            "dtype": "str", 
            "default": null, 
            "name": "dist-min-chunks"
        }, 
        {
            "info": "Base name of output files.", 
            "dtype": "file", 
            "default": null, 
            "name": "out-name", 
            "io": "output"
        }, 
        {
            "info": "Allow overwriting of existing output files. If this is set, and the output parset file exists, will raise an exception", 
            "dtype": "bool", 
            "default": true, 
            "name": "out-overwrite"
        }, 
        {
            "info": "Operational mode.\n[so] solve only;\n[sc] solve and generate corrected visibilities;\n[sr] solve and generate corrected residuals;\n[ss] solve and generate uncorrected residuals;\n[ac] apply solutions, generate corrected visibilities;\n[ar] apply solutions, generate corrected residuals;\n[as] apply solutions, generate uncorrected residuals;", 
            "dtype": "str", 
            "default": null, 
            "name": "out-mode", 
            "choices": [
                "so", 
                "sc", 
                "sr", 
                "ss", 
                "ac", 
                "ar", 
                "as"
            ]
        }, 
        {
            "info": "Output MS column name (if applicable).", 
            "dtype": "str", 
            "default": null, 
            "name": "out-column"
        }, 
        {
            "info": "If set, model visibilities will be written to the specified column.", 
            "dtype": "str", 
            "default": null, 
            "name": "out-model-column"
        }, 
        {
            "info": "Reinitialize output MS column. Useful if the column is in a half-filled\nor corrupt state.", 
            "dtype": "bool", 
            "default": null, 
            "name": "out-reinit-column"
        }, 
        {
            "info": "Which model to subtract, if generating residuals.", 
            "dtype": "int", 
            "default": null, 
            "name": "out-subtract-model"
        }, 
        {
            "info": "Which model directions to subtract, if generating residuals. \":\"\nsubtracts all. Can also be specified as \"N\", \"N:M\", \":N\", \"N:\", \"N,M,K\".", 
            "dtype": [
                "str", 
                "int"
            ], 
            "default": null, 
            "name": "out-subtract-dirs"
        }, 
        {
            "info": "Export gaintables to CASA caltable format. Tables are exported to same directory as set for cubical databases", 
            "dtype": "bool", 
            "default": false, 
            "name": "out-casa-gaintables"
        }, 
        {
            "info": "Generate summary plots.", 
            "dtype": "bool", 
            "default": true, 
            "name": "out-plots"
        }, 
        {
            "info": "Number of processes", 
            "dtype": "int", 
            "default": 0, 
            "name": "dist-nworker"
        }, 
        {
            "info": "Log memory usage.", 
            "dtype": "bool", 
            "default": null, 
            "name": "log-memory"
        }, 
        {
            "info": "Disabl
